尽量别再for循环中打印if else 或者elif 往往都不行，解决的办法是在for循环外定义一个变量，通过动态修改变量的值来控制打印的数据

写程序的思路：先搭框架，然后填充代码，一个功能测试一次，测试成功开始下一个功能

函数的触发条件：用户直接触发某个函数、或者借助代码按顺序执行的特点，使用if语句来触发函数

在Python中，搭建框架的时候灵活使用pass（起到提示占位符的效果）：
if num == 1:
        pass





一、操作系统
操作系统的本质是一段代码，支持应用软件的运行还能直接控制硬件（只有c、汇编那些语言才能直接操作硬件，操作系统可以理解为那些语言搭建好了一个平台）
给应用软件提供运行的环境并允许软件操作硬件的平台。
是软件应用操作和硬件进行交互的桥梁
优势是使各种不同的应用软件能在任何装有该系统的电脑上运行，而不需要定制化制作操作软件。类似于万能插座 
二、操作系统发展史
Unix第七个版本之后开始闭源——然后诞生了Minix，但是只供教学用，很多商业化的拓展没有采纳——一个学生（托马斯），结合汇编和Minix写出了Linux，并且开源公布到了网上，在众多网友的建议和完善下发扬光大。
Unix是用c、c++、汇编编写的
2.1、Unix——Linux（Linux的版本有很多，如Ubuntu、centos、debian等等）
2.2、所谓发行版：是指集成了一些常用的应用软件，而且还有Linux的核心代码。
Linux的核心是内核
（本质上就是一段代码）
叫：Linux内核。相当于发动机
2.3、Linux发行版本：指的是在Linux内核的基础之上进行了扩展（发动机之外装了轮子、方向盘等等），因此Ubuntu、Debian等都是在内核的基础之上进行了扩展（扩展的主要方向不一样，就形成了不同的发行版本）
三、应用领域（不同的操作系统的应用领域）
3.1、桌面领域（pc电脑的界面和常用软件集成）。
典型代表：Ubuntu、Fedora、suse linux
3.2、服务器领域
Linux在服务器领域的应用是其重要分支（主战场，桌面只是很小的一块蛋糕）
windows漏洞比较多，闭源的（只能拿人家写好的东西完完全全放上去，不能自己修改）。
Linux免费、稳定、高效等特点在这里得到了很好的体现，近年来Linux服务器市场得到了飞速的提升，尤其在一些高端领域尤为广泛。
典型代表：完全开源的Debian系列等等
3.3、嵌入式领域：
近些年来Linux在嵌入式领域的应用得到了飞速的提高
Linux是免费开源的，想怎么用就怎么用。
Linux运行稳定、对网络的良好支持性、低成本，并且可以根据需要进行软件检测，内核最小可以达到几百kb等特点，使其近些年来在嵌入式领域的应用得到非常大的提高
主要应用：机顶盒、数字电视、网络电话、程控交换机、手机、PDA等都是其应用领域，得到了摩托罗拉、三星、Google等公司的大力推广
现在把嵌入式干的活改了个名字：智能硬件（智能设备、智能家居）。把Linux操作系统的内核拿过来进行修改，不要的进行修改需要的添加，然后再烧到板子上，然后板子就能运行。（烧：把电脑上的代码放到你想要的存储设备上去，这个过程叫烧程序）
是把程序下载到板子里面去

四、虚拟软件和操作系统的关系
4.1、虚拟机和Ubuntu的区别：
虚拟机是运行在系统上的一个软件
Ubuntu是系统

五、Ubuntu目录：
5.1、在Linux系统中：
“/”代表最顶层目录，相当于windows中的c盘、d盘。因为Linux系统中没有盘符概念，只有一个根目录  /  ，所有文件都在他下面

/home：目录是系统用户目录，写的所有代码操作的所有东西尽量都安装在这个目录下的用户名文件夹内。
/user:目录，是应用程序存放的目录

5.2、Linux基本命令介绍：



六、python基础：
6.1、编译：
将人能看懂的代码转化为计算机的CPU能识别的代码（二进制代码）的过程就是编译
负责编译过程的软件（代码）就是编译器
1991年，第一个python编译器（用c语言编写的）诞生。
6.2、python解释器
python的解释器如今有多个语言实现，我们常用的是CPython（官方版本的C语言实现），其他还有Jython（可以运行在java平台）、IronPython（可以运行在.NET和Mono平台）、PyPy（python实现的，支持JIT即时编译）

6.3、python的应用场景
*web应用开发
*服务器运维的自动化脚本，操作系统管理
*科学计算
*桌面软件
*服务器软件（网络软件）如爬虫
*游戏

6.4、python3和IPython会自动补全，按tab键。
在工作中当使用命令行作为开发工具的时候使用IPython的时候比较多

6.5、注释



教程：

一、认识python和基础知识：
（1）、程序执行的过程：
人用自己熟知的语言编写好程序之后要进行编译（翻译成0/1），因为操作系统的cpu只认识0/1只有把程序编译成cpu识别的语言才能让操作系统运行（执行）程序
c语言程序的执行过程：（类比javac）
编辑（保存）——编译——执行

python语言程序的执行过程：
编辑（保存）——执行
在执行的时候用的语法：python xxx.py   
使用了python解释器，python解释器翻译完成之后并直接丢给了CPU让他执行

（2）、python解释器
我们常用的是CPython（官方版本的c语言实现）

（3）、优缺点：开源、跨平台、胶水、丰富的库
*优点：
简单-使你能够专注于解决问题而不是去搞明白语言本身。
易学-有极其简单的语法。
免费开源-是FLOSS（自由/开放源码软件）之一，它是由一圈希望看到一个更加优秀的Python的人创造并经常赶紧着。
高层语言-高层语言的特点是你无需考虑特别细节的东西，直接用就可以，你无需考虑如何管理你的程序使用的内存一类的底层细节。
可移植性-由于它的开源本质，Python已经被移植在许多平台上（经过改动他能够工作在不同平台上），如果你小心地避免使用依赖于系统的特性，那么你的所有Python程序无需修改就可以在下述任何平台上面运行Linux、Windows、OS、Android、人工智能的操作系统等等。
解释性-由于你只需要把你的Python程序拷贝到另外一台计算机上，他就可以工作了，这也是得你的Python程序更加易于移植。

面向对象-Python及支持面向过程的编程也支持面向对象的编程，Python以一种非常强大又简单的方式实现面向对象编程。
可扩展性-如果你需要你的一段关键代码运行得更快或者希望某些算法不公开，你可以吧你的部分程序用c或c++编写，然后在你的Python程序中使用它们。我们往往称Python语言为胶水语言，在系统编程阶段会讲解影响Python性能的一个东西grl（全局解释器锁），如果把这个东西剔除，那么Python的性能就能立刻飙升，如果是多核CPU那么性能更高。
称为胶水语言是因为如果你想使用C语言可以直接拿过来用，想使用c++也可以直接拿过来用

丰富的库-能通过各种库完成各种各样的功能（爬虫、web服务器、等等等等）

规范的代码-Python采用强制缩进的方式使得代码具有极佳的可读性。

*缺点：
运行速度-有速度要求的话，用c++改写关键部分吧。
国内市场较小-目前国内软件公司，尤其是游戏公司，也开始规模使用他。
构架选择太多-从另一个侧面说明Python比较优秀，吸引的人才多，项目也多。

（4）、Python应用场景
*web应用开发
*操作系统管理、服务器运维的自动化脚本
*科学计算
*桌面软件
*服务器软件（网络软件）-代理等
*游戏-很多游戏使用c++编写图形显示等高性能模块，而使用Python或者Lua编写游戏的逻辑、服务器。相较于Python，Lua的功能更简单、体积更小，而Python则支持更多的特性和数据类型

*构思实现，产品早期原型和迭代- 
Google、Yahoo等都在内部大量使用Python。

二、编程
编写文件的时候可以加数字结尾来区分文件建立的先后顺序：demo01、demo02

（1）、ipython解释器：
pip3 install ipython
使用：ipython3
比Python自带的解释器更强大，即支持shell命令，也支持Python语法，还支持自动补全.因此在使用Python命令行进行交互的时候使用ipython

（2）、注释
#这是单行注释
"#"的右边是注释，方便识别代码的含义
多行注释：
'''这是
多行注释
'''
“'''  '''”三个单引号中间的内容就是多行注释，也可以用三个多引号

（3）、Python2里面如果有中文（文件或者注释里面包含中文）编译都会报错，解决办法是在xxx.py的顶部加上一行代码：#coding=utf-8或者加上
#-*- coding:utf-8 -*-  (这种方法是Python官方推荐的)
在Python3中没有问题

（4）、变量以及类型
变量在程序当中就是一个容器（用来装东西的）
score = 100 #定义了一个变量，这个变量名字叫做score，它里面存储了一个数值 100   定义变量的格式：变量 = 数值

当变量第一次出现的时候表示的是定义一个变量，当变量第二次出现的时候表示的则是给一个已经存在的变量赋上一个新的值
程序是从上向下依次执行，后边修改的变量值会覆盖前边的值

（5）、获取用户输入的信息
high = input('请输入你的身高：')
#注意在Python2中input的含义（要想达到Python3的效果需要使用raw_input()来处理）和Python3（input中输入的内容会作为字符串来处理）中不一致

（6）、变量输出
high = input('请输入你的身高：')
high = int(high)
print ('age变量里面的值是：%d'%high)#这种方式的好处是能对字符串和数字等各种类型进行任意搭配
%d是一个占位符（d是整数的意思，此处的位置只能填整数）
%high则是需要替换占位符的实际值
具体哪个符合代表什么含义用到再去查表
写程序的一个不错的流程：
先用注释写好需要实现的步骤（#1. 使用input获取必要的信息）
然后再填写代码（name = input('请输入你的名字：')）

使用一个print输出多个值：
print('姓名是：%s，年龄是：%d，地址是：%s'%(name,age,addr))
print中可以输出空格
尽量不要采用那种+拼接的形式，如果不是一个整体字符串而是多个拼接起来的可以使用+来链接
In [3]: print('='*10+'aaa'+'='*10)
==========aaa==========

（7）、变量的类型及类型转换：
Python是一个弱类型的语言，不需要定义变量的类型，你给他赋什么值，该变量就是什么类型

判断值的数据类型：type(变量)

int(变量)
str(变量)
等，去查具体文档

（8）、判断语句
if 条件:
        需要执行的语句
high = input('请输入你的身高：')
high = int(high)
if high > 180:
    print ('age变量里面的值是：%d'%high)
else:
    print ('请输入大于180的值')

if 条件:
      需要执行的语句
else:
      需要执行的语句

（9）、当条件满足的时候可以执行多少句？
当条件满足的时候，如果代码前面都有tab空格，那么这些代码都会执行（需要执行的程序在一个代码块当中）

（10）、标识符（变量名）和关键字

标识符由字母、下划线和数字组成，并且数字不能开头

尽量起见名知意的变量名：englishScore = 100

Python推荐的规则是下划线：english_score = 100
不过小驼峰方式也可以考虑

（11）、运算符
// 整除（取的是商） 5//2 结果是2
** 乘方（幂）  2**3 结果是8
“sorry”*10 结果是一个由10个sorry单词连在一起组成的字符串

（12）、if语句的逻辑运算
在Python中if语句的逻辑运算是：or、and、not
a = 20
b = 30
if a>10 and b<40:
    print(a)
else:
    print(b)

a = 100
if not (a > 0 and a <= 50):
    print('不在0到50之间')
else:
    print(a)
if 嵌套：当你要执行的代码是在另一个条件成立的前提下执行的就需要if嵌套
一般的情况下嵌套两层比较常见，嵌套三层的时候都不常见，如果出现了多层嵌套，那么需要重新思考一下逻辑，绝大多数情况下有更简单的方法能实现目标
if 条件:
        print()
        ...
        if 条件：
                ...


（13）、if... elif...elif(else)

（14）、循环
在Python中没有do while 也没有switch 也没有i++
做判断只有if（if else 、if elif）
做循环只有while、for
程序的三大执行流程：顺序执行、选择执行、循环执行
如果你想要你程序里面的部分代码重复执行
*while循环：
当条件是true的情况，可以通过添加break来跳出循环（注意别陷入死循环）
跳出循环的两种方式：判断条件置为否、break
while 条件:
        条件满足的时候执行的事情
#注意在while条件语句中要加限制条件，不能让while一直执行
a = 1
while a < 11:
    print(a)
    a = a+1

*while嵌套：
while嵌套是在外层条件满足的时候去执行另外一个while循环
while 条件：
        while 条件：
                ...
实例：用while循环来做直角三角形
分析问题：
可以先实现一共有多少行（矩形）直接用while循环，每一次循环画五个*号（让print不换行的方法：print('*' ,end='')）
然后再解决每一行该如何做
row = 0
while row < 5:
    j = 0
    while j < 5:
        print('*', end = '')
        j = j + 1
    print('')
    row = row + 1

每行打印的*的个数等于row
row = 0
while row < 5:
    j = 0
    while j < row+1:
        print('*', end = '')
        j = j + 1
    print('')
    row = row + 1

复合赋值运算服：
+=、-=、*=、/=、%=、**=、//=
j+=1 #等价于j = j+1，其他的运算法则和+=类似
注意：a*=34-31+44-22等价于
a = a*(34-31+44-22)

使用while循环做99乘法表：
i = 1
while i <= 9:
    j = 1
    while j <= i:
        print ('%d * %d = %d\t'%(j,i,i*j),end = '')
        j+=1
    print ('')
    i+=1
\t代表的意思是相当于一个tab键可以起到对齐的作用

（15）for循环：
和while循环不太一样，while循环是只要满足条件他就会一直循环，而for循环则是name字符串中有多少个字母就循环多少次（在已知数组中依次取出每一个child）while是条件不满足的时候退出，for是取完最后一个值之后退出
name = 'laowang'
for temp in name:
        print(temp)

（16）、break、continue
break是终止循环，跳出循环开始执行循环后边的代码

continue是从continue开始跳过本次循环，然后执行下次循环
i =1
while i<=5:
        i+=1
        print('----')
        if i == 3:
                continue
        print(i)

输出结果是--1、--2、--、--4、--5
从continue开始后面的代码就不会再执行，开始执行下一次循环。


（17）、字符串在内存中的存储方式：
*字符串
cpu：能非常快的运算
硬盘：能存储大量数据，但是传输速度很慢（硬盘直接传数据给CPU一般也就100M/s，但是CPU的处理速度非常快，这种情况下CPU性能就会大量闲置）
内存：于是科学家就设计出了内存，既能存储数据又能很快的传输数据（内存的存储的数据肯定比硬盘小（16g），速度也比CPU要慢）
程序运行在内存中，在程序中定义俩变量：
num = 100
num2 = '100'
num在内存中的表现就是占用了一个字节（8g的内存能装下的字节个数：1G = 1024M  1M = 1024KB 1KB = 1024Byte(字节) 8G = 8*1024*1024*1024Byte
每个字节的最大值是255（2的8次幂-1）100转化为2进制：1100100）
所以数值100能用一个字节装下，它在内存中就占一个字节的位置

num2在内存中的表现：
因为num2是一个字符串，不管字符串里面是什么，里面的每一个字符都会占一个字节。num2在内存中的表现就是占了3个字节：'1'
、'0'、'0',因为底层的规定，此处还需要加一个'\0'.因此num2在内存中真正是占了四个字节。

获取字符串长度：len(name)

*组成字符串的两种方式：
一个是用+，另外一种是用变量%s等
《1》、c = a+b
python会自动检查a和b的类型，字符串会进行拼接，都是数字则会做加法，
在Python中不会像js中那样自动进行类型转换，int+str会报错，只能同类型变量之间进行+
 《2》、f = '===%s==='%(a+b)

*下标和切片
下标：也就是序号（横纵坐标、编号）
列表与元组支持下标索引好理解，字符串实际上就是字符的数组，所以也支持下标索引。
name = 'abcdef'
当定义好一个字符串的时候在内存中就划分好了空间，中括号中的数值就是下标name[0]取出的值就是a
如果下标的值超出了数组长度就会报错，越界了。
name[-1]取出的值就是f
切片：取一段字符串
name[2:5]取出的值就是cde
冒号左边是起始点，冒号右边是结束点的前一个字母
name[2:-2]也是结束点的前一个字节
name[2:]如果冒号的右边没写则默认会取到最后一个
name[2:-1:2] 第二个冒号的右边表示的是步长，默认的步长是1，当值为2的时候步长是2

*逆序（倒叙）：
name[-1::-1]效果就是倒叙，从-1开始直到结束，步长是-1（方向向左取值）
也可以写成name[::-1]结果也是倒叙

*字符串的操作
只需要理解什么东西能干什么活，不需要深究，用到的时候再去查
str = 'asdawdadwad'
str.然后按tab键就可以查看到所有关于字符串对象上的方法
help(str.replace)就可以查到具体的使用规则
《1》、find()
str.find('laowang')
返回的是字符串开始的位置（-1代表没有 6 代表world字符串w所在的下标）
从左向右找找到第一个之后返回第一个字符串的第一个字母的下标
此外还有index() rfind() rindex()
《2》、count()
统计字符串内有多少个满足条件的字符串的个数
str.count('world')
《3》、replace()
替换字符串内的内容
默认会替换所有满足条件的内容，可以通过添加限制条件来指定替换哪个范围里面的值
《4》、split()
切割，会返回一个列表。
注意一点，切割的时候是有损耗的，split(' ') 那么切割完成之后就不会再有空格，空格已被切除掉了
《5》、str.capitalize()
把字符串的第一个字符大写
str.title() 把所有单词的第一个字母大写
《6》、str.startswith()
str.endswitch()
判断一个字符串以什么开头，以什么结尾，满足条件返回true不满足返回false
比如检查文件的后缀是什么类型
str.endswitch('.txt')
《7》、lower()   upper()
将字符串里面的所有字母都转化成小写或大写
应用场景：将用户输入的值在判断的时候统一（用户可能输入大写或小写，如果使用lower()之后无论用户输入的是大写、小写、混合都只需要一个判断条件来判断用户输入的是什么），
《8》、ljust() rjust()  center()
左对齐、右对齐、居中
a = '想带你一起看大海'
a.ljust()  #
a.rjust()  #    
a.center(50) # 得到的结果：
"          想带你一起看大海          "
返回的字符串总共长度是50，字符串居中
《9》、lstrip()  rstrip()  strip()
删除字符串左边的空白字符
删除字符串右边的空白字符
删除字符串两边的空白字符
《10》、partition()  rpartition()
把字符串以某个字符分割成三部分
strs = 'hello name world itcast and'
strs.partition('world')#得到的结果是一个元组：
('hello name ','world','itcast and')
rpartition()是从右边找到的第一个字符串开始切割
《11》、splitlines()
以换行为切割符（将换行切割掉，返回一个列表）
《12》、isalpha() 
判断字符串里面的所有字符是不是纯字母（数字，字符都不行），返回true、false
isdigit()判断是不是纯数字,返回true、false
isalnum() 判断所有字符都是字母或数字返回true，否则返回false
《13》、isspace()
判断是不是纯空格true false
《14》、join()
将列表使用特定字符连接成字符串
names = ['aa','bb','cc']
a = '_'
a.join(names)
得到的结果是：'aa_bb_cc'


*strs.split()
如果没传递参数就会按照不可见切（切掉空白、换行、\t等）



（18）、列表
names = ['a','b','c']
这样就定义好了一个列表
在Python的列表里面可以存储任意类型的数据如：
nums = [11,22,3.14,'100','laowang']

*列表的增删改查：
《1》增加：
names.append(2)添加2到列表的最后
names.insert(位置,要添加的内容)
names.insert(0,'bajie')列表的第一个位置多了bajie，#insert嵌入插入
names = names1+names2将两个列表合并可以用+号
names.extend(names1)将names1的列表添加到names列表中

append和extend的区别：
extend是两个列表之间进行合并，只允许两个列表合并为一个列表，而append是将括号里面的内容添加到names列表中，会把括号里面的值作为一个整体添加到names中，一个大列表里面添加了一个元素，这个元素是一个小列表。
append的注意点：
a.append(b)这句话本身并不会产生结果，真正的结果在存在a里面，换句话说这句话就是一个动作，结果早就存到了a变量里面。因此动作并不能作为一个值来赋给有一个变量
a = a.append(b)结果是none，检验的方法在ipython中直接敲命令，有输出的代表有值，没输出的代表没值，也就是没有输出结果
《2》、删
先进后出，后进先出——栈
先进先出，后进后出——队列

names.pop() 把最后一个删除
names.remove（'d'）根据内容删除，从列表的开始从头往后查找，删除碰到的第一个就会结束，只删除一个

del names[0]  删除列表中的第一个元素，根据下标删除

《3》、改
names[0] = 'shashidi'
找到元素之后直接赋值为一新的值

《4》、查：in、not in
元素 in names：元素在names
元素 not in names:元素不在names中

'a' in names  返回的结果是一个布尔值


*做一个名字管理系统：
# 开发一个学员名字管理系统
#（这里有一个关键点：在什么情况下执行业务逻辑的代码？
# 在这给提供了一个非常棒的思路：当用户做出选择的时候作为事件触发的契机，代码按顺序执行，
# 用户做出选择——使用条件判断来判断用户的值——执行判断语句内的函数，因为代码是按逻辑执行的，所以并不需要实际的触发条件，
# 只是按照代码默认的执行顺序，使用if语句来触发函数）

#1.打印功能提示
# 包含功能列表
#2.获取用户的选择

#3.根据用户的选择，执行相应的功能

*如何让Python执行完一次代码之后不退出，继续下面的操作？
使用while循环，直接给while的判断条件为true，当想退出的时候在while代码块的结尾处添加一个触发break的条件：
num = 2
while True:
    num =int( input('请输入功能序号'))
    if num ==1:
        print ('....')
    if num ==2:
        break


（19）、字典：
people = {键:值,键:值}
peopel = {'name':'班长','addr':'山东','age':18}
people['name']
《1》、增
people['qq'] = 10086
《2》、删除
del people['qq']
《3》、修改
people['qq'] = 10011
《4》、查
如果key不能保证他确实存在，可以通过get来查询某个key有没有：
people.get('key')

尽量别再for循环中打印if else 或者elif 往往都不行，解决的办法是在for循环外定义一个变量，通过动态修改变量的值来控制打印的数据

*字典常见操作
info = {'name':'laowang','age':18}
《1》、len() 获取字典键值对的个数
len(info)  获取字典、列表、元组、字符串的长度，len()是python的一个方法不是某个对象的一个属性
《2》、keys:
info.keys()得到的结果是一个列表
['name', 'age']
 'qq' in info.keys() #来检查一个字典中是否包含某个key 
《3》、values
info.values()
《4》遍历items
info.items()
当对字典使用items()操作的时候，返回一个列表，列表的格式如：[('name', 'laowang'), ('age', 18)]（字典中的每一组key、value被封装成了一个元组）
《5》拆包（列表也能拆包）
a = (1,2)
c,d = a
则c = 1   d = 2
如果以后定义了一个元组，如果想把里面的元素取出来，那么可以定义几个变量=元组，那么每个变量对于的就是元组中的对应位置的数据，定义的变量要和元组的个数一致，否则会报错。因为是把a里面东西赋值给别人了，所以a并没有变。
不能直接用for循环来遍历字典数据，会报错，只能变相的通过遍历info.items()的结果来遍历字典中的数据。
for a,b in infor.items():
      print('key=%s,value=%s',%(a,b))

（20）、for循环中的else
for item in nums:
        pass
else:
        pass
for循环里面也可以跟else，只不过是用的不多，效果是for循环里面的东西遍历完之后再执行else里面的代码，在Python中不会报语法错误。
执行逻辑：for循环结束完了之后才会执行else。但是当for循环里面加了break，则else里面的代码则不会再执行。
但是当for循环里面添加了break之后：
for item in nums:
        print(item)
        break
else:
        pass
效果就会变成不再执行else里面的代码
for item in nums:
        if item['name'] == find_name:
                print('找到了。。。。')
                break
else:
        print('没有找到。。。。')

可以用来处理for循环中的if判断

（21）、元组：
要存储的数据类型是相同的往往用列表（100个班级里面每个同学的名字）
当描述一个事物的时候有很多属性需要描述需要使用字典（人的属性有年龄、名字、性别等等）
字典用来描述一个信息的时候.

nums = (1,2,3)和列表类似
元组的特点是只能查看，不能增删改。

（22）、函数
具有独立功能的代码块,当做一个整体来对待，叫做封装（把一块代码封装成一个函数）（特点：模块化，和其他代码耦合度为0，）

def 函数名():
      pass
定义完函数之后要想让函数执行必须要调用他,只有调用的时候函数内部的代码才会执行。
函数名()
定义函数在内存中的表现：
def func():  这一步在内存中的表现：在内存中划分了一块空间func，func()就是这片内存的指针,函数里面的代码会按照逻辑在func这块内存空间内再划分为更加细小的内存块，但是func这块内存空间里面的内容是他自己独有的。
编写函数的规范：
先定义函数，如果有多个函数定义在一起。所有函数定义完了之后，再调用。


def sun_num(a,b):
        result = a + b
        print(result)
sum_num(11,22) #33

*函数的返回值return：

一个函数里面如果有了return，那么就代表着该函数能够把一个结果返回到调用的地方

def get_wendu():
        wendu = 22
        return wendu
result = get_wendu()   #这样就能在函数外边拿到wendu的值 

将return出来的结果找一个变量保存，然后再使用变量

函数只要运行到return函数就结束，后面即使有代码也不再执行

如果一个函数想返回多个值，首先定义一个变量，用来存储多个值（列表，字典等），然后return返回那个变量
a = 11
b = 12
c = 13
d = [a,b,c]
return d

或者，直接返回一个列表：
return [a,b,c]
return {'a':100} 
或者：
return a,b,c   #如果用这种方式相当于把结果封装成了一个元组然后返回，得到的结果是(11,12,13)
return只能返回值或表达式不能返回一个语句
*函数的嵌套调用：
如果想拿到一个函数的结果有三个必要条件：函数内部有return+函数调用（调用之后才会执行return的结果）+变量保存

如果一个函数有返回值，但是没有在函数调用之前用一个变量保存的话，那么没有任何的意义（因为返回了结果之后没办法调用）.
完整的流程：
def get_wendu():
        wendu = 33
        return wendu
result = get_wendu()

*局部变量：
如果一个变量（wendu）已经在全局变量的位置定义了，此时在函数内部对全局变量进行修改，那么仅仅是 wendu = ‘’ 这还不够，此时函数内的wendu这个变量是一个局部变量，仅仅是和全局变量的名字相同

如果非要在函数内部修改全局变量的值：
wendu = 0
def get_wendu():
        global wendu
        wendu = 33

此时就能在函数内部修改全局变量的值。

在函数内部如果自己定义了局部变量，那么函数内部运算就会使用自己的内部变量，如果没有定义，而且全局变量中有同名变量，那么就会调用全局变量中的变量值。但是如果想修改全局变量的值那么必须要加上global

*修改或者调用函数内的一个结果可以有两种方式：return、定义一个全局变量通过global修改

*全局变量定义的注意点：
全局变量要在函数调用之前定义，因此先定义全局变量再放函数定义再放函数调用

定义全局变量的时候可以g_a = 100的方式来标记一下哪些是全局变量

*列表当做全局变量
如果列表或字典作为全局变量的时候，在函数内部修改列表时可以直接修改：
g_nums = [1,2,3]
def test():
       g_ nums.append(4)


（23）、函数的缺省参数
调用函数时，缺省参数的值如果没有传入，则被认为是默认值。
def print_info(name, age = 35):
        pass

当调用函数的时候
print_info(‘zhangsan’)或
print_info(name = 'zhangsan')


def print_info(a,b = 22, c =33):
        pass
print_info(11,c = 44)  #可以给指定的变量传参
print_info(b =11,a =22,c =44)

*不定长参数（参数的个数不定）
sum_nums(a,b,*args): #
(a,b,*c) '*c'c是自己定义的一个变量（一般为args），args打出来的结果是一个元组。除了第一个和第二个对应a，b，省下其他的参数都是args，以元组的形式存储
        pass

sum_nums(1,22,3,4,5,6,7):
        print(a,b,args)
得到的结果：1 22 (3,4,5,6,7)

注意：如果元素只有一个元素，要在元素后边加一个','即：
(22,)这个才是元组，多个元素的时候只需要加大括号就可以了
（22,33）

如果不定参的位置没有传入参数，则args的结果是：()

*test(a,b,c=33,*args,**kwargs):
        pass

另外一种不定参的形式是：**kwargs（可以为任意名字，常用kwargs）,打印的结果是一个字典。
test(1,2,33,4,5,task='任务',done='已完成')

打印出的结果是：1 2 33 (4,5) {'task':'任务', 'done':'完成'}
#在这是通过参数的顺序来判断是元组还是字典的test(1,2,3,task=99,5,6,7,8)会报错，因为传参应该是先传元组后传字典，不能颠倒位置，可以为空。又因为给指定参数传参的时候变量名是已经确定好了的，所以不会存在给固定参数传参的时候误判成字典的情况。

如下情况：
A = （5,6,7）
B  = {'name':'老王','age':18}
test(1,2,3,A,B)
则打出来的结果是：
1 2 3 ((5,6,7),{'name':'老王','age':18})
将A，B作为了元组，如果传入的参数形式不是'key'='value'的形式，那么就会作为args的子元素。
要想达到预期的效果，可以使用拆包：test(1,2,3,*A,**B)这样就能满足要求。
在形参中的*
*A拆元组
**B拆字典


（24）、引用
把值的地址给了另外一个变量。
a = 100
b = a

在Python中a=100实际的情况是：
首先在内存中开辟了一个空间，里面存入了100，然后找了一个变量名a，a只是一个指针（存储了100所在位置的地址）指向了100.
b = a 和a一样，b也是一个指针指向了100所在的位置，两个指向的是同一个位置。共用的一个100

测试a，b是否共用的一个100的方法：id(a)
id可以指向该变量指向的那个值所在的内存空间的地址。
a =100 b=100 c=100 他们指向的是同一个id 意思是一个值存储的位置是固定的 当程序想要调用100这个值的时候可以通过a,b,c 任意一个变量找到100. 当执行a =200 的时候，实际上是200存储到了一个固定的内存空间，此时a这个指针（内存地址的别名）指向了200所对应的内存空间，而不是将100改变成了200.

本质上是用a指向了另外一个数据而已，不是有个变量叫a，不是有个变量叫b，a只是一个指针，在内存中没有划分空间
变量名没有内存地址,相当于给内存地址取了一个别名.

同理适用于列表:列表就相当于一个数据，存储到了内存中的指定位置，当对列表进行修改的时候，他的内存地址没有改变，因此对列表内容改动之后其他引用地址的指针取出的内容也是改动后的值。

注意点：任何涉及到=赋值的时候统统都是引用。
当内存中的一个地址没有指针指向的话（没有被引用），那么他在内存中就没有了任何价值，成了垃圾，Python会自动进行清除。


（25）、可变类型与不可变类型
*可变类型：定义完了之后可以任意修改。
可以修改同一内存地址中的值
Python中只有两种可变类型：
列表和字典
列表和字典里面的内容可以改变，但是在内存中存储的位置没有改变
如果同时想要一个变化前的列表和一个变化后的列表该如何做？将值赋给两个不同的变量，因为是可变类型所以内存地址不同，两个变量就指向了不同的内存地址，但是初始定义的时候值是一样的。

注意：逻辑顺序
a = [100]
def test(num):
        num+=num
        print(num)
test(a)
print(a)
输出的结果是：[100,100]   [100,100]
因为a是一个列表，是可变类型，可以对他进行修改，修改后只是内容变了，内存地址并没有改变，所以num修改了a之后，a指针指向的内存地址就是num修改了之后的值

但是：
a = [100]
def test(num):
        num=num+num
        print(num)
test(a)
print(a)
输出的结果是：[100,100]   [100]

因为num和a一样是指针，当程序执行到:num = num +num
的时候先计算等号右边的值：
[100]+[100]结果是[100,100]
而num = [100,100]就相当于是重新定义了一个num变了，指向的是[100,100]所占的内存位置。
和直接修改num得到的结果不同。
*对于可变类型：
a = [1]
b =a
c =[1]
d = [1]
其中a和b内存地址一样，但是a，c，d的内存地址各不相同
如果是不可变类型：
a = 1
b = a
c =1
d =1
则a，b，c，d的内存地址都是同一个地址

两者的区别就是：num+=num是在num的基础之上进行了修改
而num = num+num则是num相加之后再赋值给num并没有对num直接进行修改

不可变数据类型：已经定义好的内存地址内的值不可改变，如果想要一个不同的值需要开辟另外一个内存空间
对于不可变变量（数字、字符串、元组）当试图去修改原来的值的时候因为原有的值不可修改，程序就会新建一个内存空间来存储新的值(改变前后的变量名不一样（如果变量名一样，那么原始值就会被内存回收，变量名重新指向了新值在内存中的位置）)：
a =100
a = a+100
因为是不可变类型，此时a+100会产生一个新的值并分配一个新的内存地址，此时的a指向的是新地址
a = 100
b = a+100
a指向的地址不变，依旧是100所在的内存地址，b指向的是一个新值所对应的的新的内存地址

交换两个变量：
a = 4
b = 5
要把a、b变量的值进行交换
需要定义一个c
c = 0
c = a
a =b
b =c
或：
a = a+b
b = a-b
a = a-b
或：
a,b = b,a



*不可变类型：定义完了之后不能够再修改。
Python中不可变类型就这三种是不可变类型（数字、字符串、元组）另外两种（列表、字典）是可变类型
数字（100本身这个值无法再改变）、字符串（a = 'hello' a[0] = 'w' 会报错，说明字符串也是不可变类型）、元组

实际应用：
在字典中只有不可变类型能当做key，如：info{'name':'laowang',100:'laowang',3.14:'laowang',(11,22):'laowang'}都是合法的


哈希算法：把给他的任何东西转化成唯一的值但长度一样的值。

在Python中，自己定义的变量名在Python解释器执行的时候会把变量名转变为一个哈希值，作为一个指针来指向数据的内存地址。

（26）、递归
使用递归实现阶乘
注意不要进入死循环，
内存泄漏：每调一个函数都会向内存申请一点空间来存储信息，当进入死循环之后内存会被占满，内存占满之后程序就会报错。
因此要用if语句来控制什么时候退出递归。
 

（27）、匿名函数
lambda 参数:执行代码的语句

lambda x,y:x+y
如果要使用匿名函数，需要找个变量来保存他：变量 = lambda x,y:x+y

func = lambda x,y:x+y
调用的时候：
func(11,22)

普通函数与匿名函数的区别：
def test(a,b):
        a+b
test(11,22)

func = lambda a,b:a+b
func(11,22)

如果普通函数里面没写return语句那么什么都不会返回。但是匿名函数不写return默认就自带return（既然默认的结果是自带return的，就代表着：后边就只能写表达式，不能写print，input等，就相当于只能写return后面的东西。）如果想要实现比较复杂的函数那么使用def声明更好，如果只是实现很简单的函数那么可以使用匿名函数（因为函数体只能包含return后面的内容，不能使用if等语句）

*匿名函数的好处：
默认排序：nums.sort() #从小到大排序

infos = [{'name':'laowang','age':18},{'name':'xiaoming','age':10},{'name':'haha','age':20}]
给上面列表排序：
infos.sort(key = lambda x:x['name'])
#调用infos列表的sort方法对infos里面的内容进行排序，排序的规则是按列表中的name进行排序：key = name
如何获取name的值，就需要通过匿名函数来获取：lambda x:x['name']
sort的语法规则是两两比较然后位置互换（依次比较infos列表中的元素）

*匿名函数的应用2
写一个可以对两个数字进行加减的函数
def test(a,b,func):
        result = func(a,b)
        print(result)

test(11,22,lambda x,y:x+y)#加法
test(11,22,lambda x,y:x-y)#减法

在这是定义了一个匿名函数进行了简单的计算，func只是个指针，当test调用的时候会执行func所对应的内存空间里面的数据。

事实证明，函数的参数里面还可以传入另外一个函数：
def sum_nums(x,y):
        return x*y
def test(a,b,func):
        result = func(a,b)
        print(result)
test(11,22,sun_nums)#会得到242

但是对于简单的计算匿名函数更简单清晰。

*Python是动态语言，是指在程序运行的过程当中可以修改他的运行方式，
def test(a,b,func):
        result = func(a,b)
        print(result)
甚至可以让用户输入一个函数然后再执行用户输入的那个函数:

 func_new = input('请输入一个匿名函数：')
func_new = eval(func_new)
#eval(func_new) #eveal是吧字符串转化成语句（相当于去掉了字符串两边的引号）
test(11,22,func_new)

这样当程序运行的时候会让用户输入一个匿名函数，匿名函数输入完成之后使用eveal方法将字符串转化成语句，然后调用test()方法。


（30）、文件简介：
*文件的作用：把数据存储起来   
在Linux系统下有一个说法：一切设备皆文件（任何东西都是文件，鼠标键盘等都会按文件来对待）

*使用程序去操作文件
使用Python里面操作文件的语法
《1》、open()函数
打开文件或者创建一个新文件open(文件名，访问模式)
f = open('test.txt','w')
#open的第一个参数支持相对路径和绝对路径：f = open('../test.txt','w')
r:只读打开，文件的指针将会放在文件的开头。是默认模式
w:打开一个文件只用于写入（读不出来）。如果该文件已存在则将其覆盖，如果该文件不存在，创建新的文件
a：追加
r w a 是基础操作，操作通常文件的所有方式就是r w a 剩下的就是rwa的组合操作方式
如果操作的是普通的文本文件只用rwa就能满足要求，如果操作的是MP3、图片等二进制文件就在后边在加个b
#b代表二进制
rb：二进制打开一个文件用于只读
wb：
ab：

r+ w+ a+:读写但是r+打开文件的时候该文件必须得存在，而且是在原有内容的末尾添加内容

rb+ wb+ ab+:以二进制格式打开一个文件可以读写

《2》、close()
f.close()
关闭文件
注意打开文件操作完了之后一定要关闭文件
f = open()
pass
f.close()
《3》、write()
想文件里面写入数据
f.write('asdhaodjaiwjda')
返回值是一个写入的字符的个数

（QQ的历史聊天就是读取本地的文件找到的）

《4》、read() readlines() readline() 
读取文件中的内容，有一个参数，默认是读取全部内容，如果传入一个数值2 就是读取前两个数据（字符串）
如果连续调用read()则下次调用的时候是从上次读取的位置的结尾开始的，是一个连续的，而不是每次从头开始读取。读到没东西的时候就会返回一个空字符串
content = f.read() #找一个变量存储返回值，方便调用
f.read(1)

注意：f = open('hei.txt','w')
pass
#在这里面只能写，因为是w模式打开的，不允许在里面读数据
f.close()

《5》、文件的备份

def copy_file():
    # 获取要复制的文件名
    name = input('请输入要复制的文件的完整的文件名：')
    print(name)
    #打开需要复制的文件，因为是复制，所以用只读方式打开
    file = open(name,'r')
    #创建一个新的文件文件名是xxx[复件].xxx
    #获取name并切割，然后在拼接
    new_name = name.split('.')
    new_name[0] = new_name[0] + '[复件]'
    a = '.'
    new_name = a.join(new_name)    
    print(new_name)
    new_file = open(new_name,'w')    
    #获取原文件里面的内容
    content = file.read()
    print(content)
    #将文件内容写入到新文件里面
    new_file.write(content)
    file.close()
    new_file.close()
    #读取新文件里面的内容
    new_content = open(new_name,'r')
    new_content1 = new_content.read()
    print('复件里面的内容是：%s'%new_content1)
    new_content.close()
copy_file()

*f.readlines()
会把文件中的内容全都读出来，而且每遇到一个换行，就会把接下来的内容作为一个元素放到列表中去。
列表中的每个元素都是文件中每一行的内容
read()返回值是一个字符串
readlines()返回值是一个列表，每个元素是字符串（对应每一行的内容）

*f.readline()
每次读一行，连续使用的时候承接上一次，返回值是字符串

*如果电脑的内存有4g，但是要读取的文件是5g，那么怎样把文件的数据读取到内存然后进行处理呢？
以后操作比较大的文件尽量不要用read(),因为有可能会内存溢出

解决办法是分多次读取
while True:
        content = f_read.read(1024)
        #每次可以读1M：1024*1024
        if len(content) == 0:
                break
        f_write.write(content)

《6》、文件的定位读写 seek(偏移量，方向)
f.tell()#返回值是当前读到了哪个位置 
指的是当打开一个文章之后，不想从头开始读，想从其他的某个地方开始读。文件定位读写的作用就是可以设定一个起始位置

seek就定义了一个指针，指针指到哪，那么文件的读写位置就在哪

seek(offset,from)
offset:偏移量
from:方向（0表示文件开头 1表示当前位置 2表示文件末尾）
 
f = open('test.txt','r')
f.seek(5,0)#此时已经将文件定位到了从开头开始的第五个位置。
f.tell() #得到的结果就是5
f.read(1) #此时再读到的内容就是第从开头开始的第5个字符

一个文件既想写又想读的时候要合理的控制好seek，因为在一个有内容的文件里面如果指针在末尾，那么在使用read的时候依旧读出来的是''

《7》、使用程序对文件、文件夹的相关操作。
首先导入os（os就是操作系统工具箱）
import os
*文件重命名（可以修改文件和文件夹的名字）
import os
os.rename('test.txt','test111.txt')

*删除文件
import os
os.remove('test.txt')

*创建文件夹
import os
os.mkdir('demo')#makedir

*获取当前目录
import os
os.getcwd()

*改变默认目录
import os
os.chdir('../')#changedir
如果想在另外一个文件里面创建文件，可以使用open('haha/test.txt','w')
#open()的相对路径来创建
也可以通过改变默认目录的方式，将当前目录重定向到haha文件下：
os.chdir('haha')#此时的操作路径就变到了haha文件夹下

*获取目录列表
imort os
os.listdir('./')
os.listdir('haha')
*删除文件夹
import os
os.rmdir('haha')

*批量修改文件名
要想批量修改某个文件夹内文件的名字，要重定向到该文件夹下，才能找到对应的文件然后修改os.chdir(dir_name)

import os
#创建一个文件夹名字叫move
# os.mkdir('move')
#修改move文件夹的名字为tv
# os.rename('move','tv')
#重定向到tv文件夹下并创建txt文件
# os.chdir('tv')
# i = 0
# while i<10:
#     f = open('第%d个文件.txt'%i,'w+')
#     f.write('这是tv文件夹下的第%d个文件'%i)
#     f.close()
#     i+=1
#获取需要重命名文件夹的名字
dir_name = input("请输入要获取的文件夹的名称：")
#获取文件中所有文件的名字
file_names = os.listdir(dir_name)
#对获取的名字进行重命名
os.chdir(dir_name)
for name in file_names:
    print (name)
    # new_name = '[第一影视]'+ name
    # print(new_name)
    os.rename(name,'[第二影视]'+ name)
os.listdir()


四、面向对象：
面向对象和面向过程和函数都是解决问题的一种思路
（1）、面向对象（OO）：将数据与函数绑定到一起，进行封装，这样能够更快速的开发程序，减少了重复代码的重写过程
（2）、类和对象
*类：就是一个模板，一个模糊的轮廓
类由三个部分组成：
《1》、类的名称：类名
《2》、类的属性：一组数据
《3》、类的方法：允许对进行操作的方法（行为）

*定义一个类：
class 类名（类名使用大驼峰命名法）：
        #属性
        #方法（def）
               

class Cat:
        #属性
        #方法
        def eat(self):
#只要是在类里面定义了方法就要传self参数
                print('猫在吃鱼')
        def drink(self):
                print('sadasda')

类不会自动执行

根据类创建对象：
往往用一个变量将对象保存起来
Cat()#这就根据类创建了一个新的对象 实际上就是在内存里面额外开辟了一片内存空间，这句话就是额外向操作系统要了一片内存空间
tom = Cat()#往往用一个变量将对象保存起来
在内存里面额外开辟了一片内存空间之后会返回对象的引用（也就是新开辟的内存空间的地址）
 tom里面存的就是新开辟的内存空间的地址

这就是一个完整的创建对象过程

*调用对象的方法：
tom.eat()
tom.drink()
tom这个变量指向的是新的内存空间，eat()是对象里面的方法，所以调用对象里面的方法就是:tom.eat()

*给对象添加属性：
尽量不要把属性定义在类里面，放到对象里面是最合适的

tom.name = '汤姆'
tom.age = 50
给tom对象里面添加了两个属性（属性就是变量）：name、age
这两句话就相当于在tom指向的那个内存中添加了两个属性（此时内存中有两个属性两个方法）

*获取对象的属性：
print(tom.name,tom.age)

*lanmao = Cat()
#当定义蓝猫的时候因为重新调用了Cat() 所以在内存中又重新划分了一片空间，lanmao这个变量就是指向的那片内存空间的地址
lanmao和tom两个变量指向不同的内存地址
lanmao.name = 'lanmao'
lanmao.age = 20

*self的注意点：
self的作用就是你通过哪个对象去调用类里面的方法，这个self就指向了这个对象。
self是你通过哪个对象调用的self就是指的这个对象
self的应用：
class Cat:
        def introduce(self):
                print('%s的年龄是：%d'%(self.name,self.age))
#如果写成%(tom.name,tom,age)就会造成其他的对象调用的对象也是tom里面定义的属性

对象不能直接调用，只能调用对象的方法：tom.eat()

*__init__方法：
定义在类里面，作用是初始化对象

class Cat:
        def  __init__(self):
               pass
        def eat(self):
                pass
创建对象的过程：
创建一个对象》Python解释器自动调用__init__方法（会执行里面的代码）》返回该对象内存地址
init方法使用：
  def  __init__(self,new_name,new_age):
               self.name = new_name
                self.age = new_age

init只会在对象生成的时候执行一次，对象生成完了调用里面的方法的时候不会再执行init里面的代码
这里面定义的参数是在创建对象的时候传入的，而不是调用对象方法的时候传入的。
tom = Cat('汤姆'，20)

而调用对象的方法的时候传入的参数就是对应类里面对应方法的参数
...
def eat(self,num):
        print('%s吃了%d Kg的鱼'%(self,num))
...
tom.eat(2)#输出：汤姆吃了2Kg的鱼

*__str__方法
对应的是对象的描述信息
class Cat:
        ...
        def __str__(self):
                return 'hahaha'
        ...
在没有定义str方法的时候：
print(tom) 返回的结果是tom的内存地址
当定义了str方法的时候print(tom)返回的结果就是str return 里面的内容


注意self并不是局部变量是对象里面添加的变量，哪个对象调用self则self就指向谁

*在类里面，定义的属性，可以通过self在函数之间共享
对象与对象之间彼此独立，修改各自的属性不会影响到其他对象。


*对象：是模板仔细加工后的成品



*类和对象的区别关系
对象需要类才能创建出来
如果仅仅是个概念就是类，如果是描述的一个具体的东西（世界上独一无二的那个具体东西）就是对象

*只要告诉了对象的引用，就能获取对象里面的属性。如果想控制属性不被第三方调用，那么就将属性放到一个函数里面通过return返回值来传递值。让第三方调用函数，这样就可以控制权限了。

4.1、隐藏对象的属性
*私有属性
在属性的前边加了俩下划线就是私有属性：__name
保护对象的属性，如果有一个对象，当需要对其进行修改属性时，有两种方法：（1）、对象名.属性名= 数据——>直接修改
（2）、对象名.方法名()——>间接修改
为了更好的保存属性安全，即不能随意修改，一般的处理方式为：将属性定义为私有属性然后添加一个key调用的方法，供调用

class People:
        def __int__(self,name):
                self.__name = name #__代表的是私有属性，不能被外界直接获取print(xiaoming.__name) 得到的结果是__name属性不存在
                self.age = 20 #可以被外界直接获取 print(xiaoming.age)得到的结果是20
        def getName(self):
                return self.__name
        def setName(self,newName):
                if len(newName) >= 5:
                        self.__name = newName
                else:
                        print('error:名字长度需要大于或等于5')

xiaoming = People('dongGe')
print(xiaoming.__name)  # 报错'People' object has no attribute '__name'   People对象中没有__name这个属性
xiaoming.getName() # 输出结果是：'dongGe'
print(xiaoming.age) #输出结果是：20

使用隐藏对象属性的方法来设置属性的好处是可以对修改的属性进行判断（比如在修改name的时候，如果不用隐藏属性的方式那么name可以为任意值，数字符号等，但是使用了隐藏属性的方式之后就可以对name属性进行检测，并进行合理的提示）

*私有方法：
在定义的方法名前面加两个下划线就是私有方法：def __getName(self):
同私有属性一样，不能通过对象直接调用属性，该属性只能在类内部使用。私有方法也不能通过对象直接调用，该方法只能在类里面进行使用
私有方法可以做一些前置条件的获取判断等处理
class SendMsg:
    ...:     #私有方法
    ...:     def __send_msg(self):
    ...:         print('-----正在发送短信-----')
    ...:     #公有方法
    ...:     def send_msg(self,new_money):
    ...:         if new_money >1000:
    ...:             self.__send_msg()  #调用私有方法需要在self对象上调用
    ...:         else:
    ...:             print('余额不足，请先充值在发送短信')

In [21]: send = SendMsg()

In [22]: send.send_msg(10)
余额不足，请先充值在发送短信

*__del__()方法：
创建对象后，python解释器默认调用__init__()方法
当删除一个对象时，python解释器也会默认调用一个方法，这个方法为__del()方法
（当想要删除一个已经创建好的对象的时候回调用del方法）

class Dog:
        def __del__(self):
                print('该对象正在被删除')

xiaobai = Dog()
xiaohei = Dog()
dog1 = xiaobai #此时dog1和小白都指向的是同一个对象
del dog1 #此时只删除了dog1这个指针 xiaobai指针依旧存在，xiaobai依然有效
del xiaohei
print('-------------------------------------------------')
#硬链接：数据只有一个但是可以有很多个名字
比如一个内存地址为：1
名字为：aa  bb cc
当del aa的时候实际删除的是aa这个名字，内存为1的里面的内容并没有删除 只有当cc也删除之后，此时指向内存空间的指针已经没有了，那么该内存空间就会被垃圾回收机制回收。

当执行del xiaohei之后输出的结果是：
'该对象正在被删除'
'----------------------------------------'
注意，要在该对象已经没有指针指向的时候会自动触发del方法

！注意：同时，当退出程序的时候，因为CPU要清理所有的内存空间，此时也满足垃圾回收机制（清理该程序所占用的内存空间）此时也会触发对象的del方法
如：
xiaohei = Dog()
xiaobai = Dog()
当在命令行中执行exit()
会打印两次print里面的值，说明del执行了两次
因此主动删除或系统清空内存的时候（删除的本质也是情况该位置的内存）都会触发对象del方法


指向对象的指针的个数叫做引用计数

*测量指针的个数（查看引用计数的值）
查看该对象当前被几个指针指向：
import sys
sys.getrefcount(对象) #这个地方的参数是对象名xiaobei = Dog() 此时就应该写成getrefcount(xiaobei)
就可以测出对象的引用的个数+1
就是比实际引用的个数多一个

*继承：
场景：比如之前已经定义了一个动物的类，该类有吃喝两个属性（方法）
然后有需要定义猫和狗两个类，那么还需要再次定义吃喝两个属性（方法）嘛？

类的继承：为了在程序中少写一些代码，因为如果所有的东西都是重新定义了一次的话，那么当修改代码的时候就要把所有定义过的地方都重新修改一次（麻烦、可能会漏掉等bug）

动物是父类（基类）
猫是子类（派生类）
猫继承的动物

class Animal:
        def eat(self):
                print('-------吃--------')
        def drink(self):
                print('-------喝--------')
        
class Dog(Animal): # 在Dog类里面添加Animal参数，此时Dog类就继承了Animal类
        def run(self):
                print('-----跑-----')


wangcai = Dog()
wangcai.eat()  #此时就能打印出'-------吃--------'因为Dog类以及继承了Animal类

class Xiaotq(Dog):
        def fly(self):
                print('-----飞------')
        
xiaotian = Xiaotq()
xiaotian.eat()  #输出结果'-------吃--------'，可以一直往上继承

所谓继承就是你只要在基类里面把基本的功能实现了，然后在子类里面你想要基类里面的功能，就可以直接继承基类，然后子类里面就有了基类的功能


*重写：
子类里面重新定义来覆盖父类里面的方法（属性），保证父类的纯净。

因为继承父类的可能会有多个子类，每个子类的属性（方法）都有自己特有的值（该方法或属性是从父类里面继承的，但是值不一样），（还有自己特有的属性（方法），该方法是在类里面单独定义不是继承的父类的），为了保持父类的纯净（不会被子类污染），因此需要重写，重写的意思就是即使父类里面已经定义了某个属性（方法），但是因为需要的属性值不一致，所以需要在子类里面重新定义一次，这样就会优先使用子类里面定义的。

class Xiaotq(Dog):
        def fly(self):
                print('-----飞-----')
        def run(self):
                print('----狂奔-----')

调用被重写的方法，第一种：
（功能只留一份，尽量保证少写重复代码）
class Xiaotq(Dog):
        def fly(self):
                print('-----飞-----')
        def run(self):
                print('----狂奔-----')
                Dog.bark(self)  #当狂奔完了之后没力气了只能跑了，使用这种方法可以调用到父类里面的方法，而且必须要传入self。因为在调用和父类重名的方法的时候只会执行子类里面的方法，因此要想执行父类里面的方法就要在子类方法的里面调用父类的方法

调用被重写的方法，第二种：
class Xiaotq(Dog):
        def fly(self):
                print('-----飞-----')
        def run(self):
                print('----狂奔-----')
                super().bark()   #这是调用重命名父类的另外一种方法。调用super()会得到一个结果，然后结果里面有bark()方法，这个方法的好处是不用每次修改父类之后再改一次Dog.bark(self)


*私有方法私有属性在继承中的表现
类的私有方法和属性不能被子类继承（子类里面不能调用父类的私有方法和私有属性），但是如果是在父类里面使用私有方法和私有属性，然后把结果赋给一个公有方法，那么就能拿到私有方法的属性，本质上是私有方法和私有属性只能在类内部使用，任何将私有方法和私有属性直接拿到类外面直接使用都会报错。不能直接拿出来用，但是可以在内部计算完成之后将结果赋值给一个公有的属性或方法，然后调用公有的属性或方法来使用


*多继承
继承多个类的属性和方法（驴和马杂交生出骡子）

class Base(object):
        def test(self):
                print('----base----')
class A(Base):
        def test_a(self):
                print('----test_a----')
class B(Base):
        def test_b(self):
                print('----test_b----')

class C(A,B):  #多继承类，此时的C类既继承了A这个类也继承了B这个类，以此类推还能继承DEF等类，中间用逗号隔开
        pass
c = C()
此时c这个对象能调用test、test_a、test_b等方法

A、B的父类可以是不同的没有限制

object类是python在运行起来之后python定义的，object类是所有类的最终老大，是所有类的最顶层的一个基类，这是Python3推荐的一种方法，比class Base：这种定义方法功能更多


*多继承的注意点
如果C类里面定义的方法，在A、B、Base中都有，那么会根据就近原则来调用 优先调用C里面的，因为A在B前面，所以C里面没有下一个会调用A里面的，然后B 然后Base然后object

调用的顺序是按一个元组里面元素排列的顺序决定的，元组获得方法：
print(C.__mro__)
C.__mro__#  类名.__mro__   C是最后的那个类，得到的结果是一个元组(<class '__main__.C'>, <class '__main__.A'>, <class '__main__.B'>，<class '__main__.Base'>，<class 'object'>)
里面元素的顺序就是在调用方法时查找方法的顺序，如果在某个类中找到了方法，那么久停止搜索

mro里面元素的顺序是某个大神使用C3算法来设计的，并不是按照单纯的找到A，然后找B，然后找Base这种方法，因此要确定函数具体调用的哪个类的时候要使用:类名.__mro__这种方式来确定

在真正设计程序的时候类里面尽量不要出现重名的方法，如果没办法避免，可以使用A.test(self)这种方式来调用指定的父类的方法

*多态：
多态的概念是应用于java和c#这一类强类型语言中，而Python崇尚‘鸭子类型’
所谓多态：定义时的类型和运行时的类型不一样，此时就成为多态

class Dog(object):
        def print_self(self):
                print('大家好')
class Xiaotq(Dog):
        def print_self(self):
                print('hello everybody')

def introduce(temp):
        temp.print_self() #该方法在定义的时候并不确定是调用的哪个类里面的方法，只有在传入确定的参数之后才能确定调用的是谁的方法，这就是多态

dog1 = Dog()
dog2 = Xiaotq()

introduce(dog1)
intrudoce(dog2)

Python是动态类型语言，在定义introduce这个方法的时候是没办法定义temp是什么类型的，只有在传入具体的参数之后才能确定到底传入的是什么类型

因为是动态类型语言所以Python的多态体现的并不明显。而java（c#）等多态就会体现的非常明显

面向对象的三个基本要素：封装、继承、多态
封装：
继承：子类继承父类
多态：定义的时候不确定调用哪个功能，当调用的时候才确定调用的具体哪个方法



*类属性和实例属性
下面例子中names就是类的属性而self.name就是实例的属性
类的属性和对象的属性完全不同
class Tool(object):
        #属性
        names = []
        #方法
        def __init__(self,new_name):
                self.name = new_name
创建对象的本质：
其实之前完全是为了方便理解，所以举了一个不恰当的例子，如果这个类创建了一万个一百万个对象难道要把类里面的东西全都复制一百万遍嘛？所以对象创建的本质不是这样的。
实际上是类在创建的时候开辟了一份空间，存放了一份代码（包括类的属性和方法）。当创建对象的时候，对象也会开辟一份空间，存放的是属性（该对象自己的属性）和一个特殊的属性（该属性能够知道这个对象的class），当执行对象的方法的时候实际上是会通过那个特殊的属性找到该对象的类，从他的类里面去找方法（该对象开辟的空间里面没有方法的代码），

类在Python程序里面也是一个对象，我们称之为类对象（凡是看得到摸得着的都是对象，虽然类是一个模板，但是也能看得见摸得着）

同样都是对象，因此区分为类对象、实例对象、类属性、实例属性

而通过类的名字创建出来的对象我们具体称之为实例对象（dog1就是一个实例对象）

实例对象里面的属性称之为实例属性

类里面的属性叫实例属性

类属性在实例对象之间共享，而实例属性在实例对象之间没有关系

类的方法如何获取类的属性呢？
因为类名Tool就是指向的该类的内存空间，因此可以使用Tool来拿到类的属性
class Tool(object):
        #属性
        names = []
        #方法
        def __init__(self,new_name):
                self.name = new_name
                #获取类的属性，并进行操作
                Tool.names.append(new_name)
打印names的时候可以直接通过类来获取到：
print(Tool.names)
也可以通过实例对象来获取
tool1 = Tool('铁锹')
tool2 = Tool('脸盆')
print(tool1.names)  #输出的结果是 ['铁锹', '脸盆']

和对象有关系的是实力属性：self.name

*类方法和实例方法
class Game(object):
        #类属性 因为该属性是在类里面定义的属于类
        num = 0
        #实例方法  因为该方法是用来处理实例属性而存在的
        def __init__(self):
                #实例属性 因为该属性是定义在self上的，self是保存对象（谁调用self就指向谁）,注意在这的self是人们为了更清晰描述该参数的作用而普遍使用的一个单词，此处的单词可以为a等，同理cls也是
                self.name = 'Dnf'
        # 类方法  只要在方法的前面写上了@classmethod 那么这个方法就变成了类方法，类方法就是为了处理类的属性而存在的（@classmethod（装饰器）、cls注意这俩）
        @classmethod
        def add_num(cls): #cls是保存类的
                print(clas.num)

调用类的属性和方法：
Game.num
Game.add_num()
也可以使用实例对象的方法来调用类的方法
game = Game()
game.add_num()

如果一个程序里面既有类又有函数，那么效果就不太好，在开发的时候如果想用类去处理那么就统统用类，如果想用函数去处理那么就统统都用函数（既有类又有函数给人感觉就显得不伦不类）

在实际开发中可以把函数直接放到类里面，因为该方法和类以及对象并没有直接的联系，只是为了处理方便写的一个处理方法，因此需要把该方法定义成一个静态方法：
@staticmethod
def print_menu():
        print('------------')

该方法既和类没有关系也和对象没有关系，就是把一个外部的函数（可以有参数，也可以没参数）移动到了类里面

如何调用静态方法呢？
第一种直接通过类名调用：
Game.print_menu()
第二种通过实例对象调用：
game.print_menu()

如果要操作实例对象的属性，那么就使用实例对象的方法
操作类的属性，就使用类的方法
一个操作既和类的属性没关系也和实例对象的属性没关系那么就使用静态方法
虽然实例对象的方法也能间接操作类的方法但是从程序执行的效率上来讲还是各司其职效率更高
只要是类的方法和属性都可以用类名或者实例对象来调用


*设计一个4S店：
思路：整个系统都有哪些物体组成，然后分析各个物体都有什么功能和属性
购买是属于4S的功能，开车和停车是属于汽车的功能
#设计4S店（既然是定义的4S店，那么肯定需要一个4S店实体，汽车实体，
# 和购买行为，提车开回家行为。又因为4S店不止一家，汽车品牌不止一个，因此需要定义4S店和汽车俩类）

#首先定义一个4S店的类，用来实例化具体的4S店（4s店不止一个）

#然后定义一个汽车的类，用来实例化汽车（汽车有很多品牌)

#再定义一个买汽车的方法,因为购买汽车的行为是4S店的功能，因此购买的方法定义在4S店这个类里面

#再定义买完汽车之后的行为（开走，放歌，停车），因为开车，停车等是在汽车的功能，所以定义在汽车这个类里面

在框架中填充代码：
#首先定义一个4S店的类，用来实例化具体的4S店（4s店不止一个）
class CarStore(object):
    def buy(self,money):
        if money > 30000:
            return Car()
        #注意这个地方可以直接返回一个类的实例化对象（效果等同于  buy_car = Car()  return buy_car
        # 只不过在使用该方法的时候注意，因为是返回的一个实例对象，因此要用一个变量接收）
        else:
            print('金额小于3万不能买到一个汽车')
    pass
#然后定义一个汽车的类，用来实例化汽车（汽车有很多品牌）
class Car(object):
    def move(self):
        print('汽车在移动。。。')
    def music(self):
        print('正在播放音乐')
    def stop(self):
        print('汽车在停止。。。')
    pass

#再定义一个买汽车的方法,因为购买汽车的行为是4S店的功能，因此购买的方法定义在4S店这个类里面

#再定义买完汽车之后的行为（开走，放歌，停车），因为开车，停车等是在汽车的功能，所以定义在汽车这个类里面

#类定义完了之后就是实例化完成一个具体的操作流程

car_store = CarStore()

num = int(input('请输入购买汽车的价钱：'))
car1 = car_store.buy(num)#注意这，因为buy方法里面是return，所以必须要有一个变量来接受，又因为
#返回值是Car这个类的实例对象，所以此时car1就是Car这个类的实例对象

car1.move()
car1.music()
car1.stop()


*如果4S店是一个北京现代的4S店，当用户买车的时候可以指定买哪个型号的（汽车型号有索纳塔、名途）
分析：因为索纳塔和名途都是车型号，每个型号的车不能只有一辆，所以这两个型号的车应该是两个类，又因为这两个型号都有汽车这个类的功能，属于汽车的子类，所以定义的两个类可以继承汽车这个类。
又因为用户可以选择汽车的型号，所以4S店这个类的buy（）方法需要新加入一个参数车的型号，并根据型号和价位进行判断。
如果在buy（）方法中使用if语句进行判断来确定车的类型，那么就会产生一个问题，每次添加一个车的类型都需要再改动buy（）中的代码，这种情况会导致代码臃肿（有10000个型号就要添加10000个判断），也很麻烦（每次多一个汽车型号都要去添加一次，本来买汽车的型号是汽车的属性，并不是4S店的属性，这种设计模式使汽车类型的类和4S店的类耦合程度很高）。车的类型和店铺没有太大的关系，因此要降低耦合度。

通过定义一个额外的函数来达到解耦的目的：
解耦的一种处理方式，把buy中的if判断封装成一个函数select_car()，buy（）只需要调用select_car(type)，传入参数就行。而select_car(type)来具体处理返回值的问题，这样汽车类型的类和4S店的类之间就没有了耦合关系，4S店只需要调用select_car(type)这个函数就行，不用管其他的事情。而每次添加一个汽车类型就在select_car(type)中添加一个判断，也不用管4S店类中是如何使用的。每个人专注于自己的事情，不需要插手别人的事情。当升级select_car(type)的时候和4S店的类没有关系，当升级4S店的类的时候和select_car(type)也没有关系
这种模式在实际开发过程中，如果一个程序很大几万行代码，三个人来开发，不可能在实际开发过程中时时刻刻都沟通，而且如果一个人的代码改动了都需要另外两个人也改动代码来配合，这是很不友好的开发方式。因此这种时候就需要在开发之前将有交互的地方封装成函数，名文规定出来，那些方法干了那些事，参数是什么，返回值是什么，然后生成开发文档，所有开发人员都遵守里面的规则。如：如果我想得到一个车的引用这个值，那么我只需要调用某个函数，传入规定的参数就能获取到，而不需要再和别人商量拿去或者配合你修改代码。每个人专注于自己的事情（需要什么值（直接调用方法），输出什么值（按开发文档封装好函数））而不需要管你需要的值是通过什么方法怎么得来的，和别人的工作解耦。
代码：
class CarStore(object):
    def buy(self,money,car_type):
        if money > 30000:
          return select_car(car_type)
        else:
            print('金额小于3万不能买到一个汽车')
    pass

#类解耦，重新定义一个函数来达到目的
def select_car(car_type):
    if car_type == '索纳塔':
        return Suonata()
    elif car_type == '名途':
        return Mingtu()
    elif car_type == 'ix35':
        return Ix35()


python中的设计模式：在python程序当中为了解决某一类问题，而设计了一些模板（规定了一些条条框框的规则），本质上就是解决某一类问题的时候调用哪一个套路。

而上边使用函数解耦的方式，在使用面向对象编程的时候把函数放在类里面，通过调用类来使编写风格统一（函数和类混搭四不像），好像只是把生产环节重新创建了一个类，称作为：简单工厂模式。效果通过添加了一个类达到了其他两个类的解耦
将函数改成类的模式，代码：
首先把函数放到一个类里面：
class Factory(object):
        def select_car(self,car_type):
            if car_type == '索纳塔':
                return Suonata()
            elif car_type == '名途':
                return Mingtu()
            elif car_type == 'ix35':
                return Ix35()
然后在4S店的类里面引用：
class CarStore(object):
    def __init__(self):
        self.factory = Factory()   #首先将Factory类实例化赋值给CarStore的factory属性
    def buy(self,money,car_type):
        return self.factory.select_car(car_type) #然后引用实例对象里面的方法
    pass

有时间可以看一本书：《python的十大设计模式》，就是在学套路，当遇到什么样的问题的时候使用哪种套路去解决


*再定义一个宝马的4S店：
工厂方法模式：在流程已经规定好了的前提下，在父类里面不去实现具体的函数，只定义流程（在基类里面定义好了流程，但是在基类里面不能让方法实现成功，因为基类里面并不能确定具体是哪个4S店的车，具体的实现让子类去定义实现，基类只负责调用），在子类里面去实现具体函数的方式。
好处：

这个有时间再去详细了解


*__new__(cls)方法：#会把类当做第一个参数传进去

class Dog(object):
    pass

xtq = Dog()  
#当调用Dog（）的时候实际是进行了三个步骤：
创建一个对象——调用__init__方法——返回对象的引用

而__new__(cls)方法就是创建对象的方法，如果类中没有写new方法，则会继承object这个父类的方法（Python3中即使类中没有传入object也会默认继承有object这个父类）。而当自己定义的类中写了new方法，本质上是在object子类中重写了new方法。

class Dog(object):
    def __init__(self):
        print('------init方法-----')
    def __new__(cls):
        print('----new方法-----')

xtq = Dog()

注意我们在Dog这个类中定义了new方法，本质上就是在子类中重写了new方法，但是我们定义的new方法里面只有一行代码，打印了一串文字，所以程序会出问题。本来new方法的作用就是创建一个对象，而我们在定义的new方法里面却没有实现该功能，所以程序会出问题。

通过打印id(cls)和id(Dog)可以发现两个指向的是同一个内存地址，因此cls就是指的Dog类（Dog指向的谁cls就指向谁）

为了让对象创建成功，就得让new方法有创建对象的代码，但是我们并不知道如何写代码，所以我们可以调用object父类的方法来实现创建对象的功能。

class Dog(object):
    def __init__(self):
        print('------init方法-----')
    def __new__(cls):
        print('----new方法-----')
        object.__new__(cls)

而object.__new__(cls)的返回值是创建对象的引用，为了我们能够使用这个引用，我们需要return，以保证我们写的new方法的返回值和object.__new__(cls)的返回值一致，以达到创建对象的目的
 def __new__(cls):
        print('----new方法-----')
        return object.__new__(cls)

通过打印出来的结果：可以看出程序执行的过程是先执行new方法，然后执行init方法，然后才会执行其他的方法

当我们在一个类中自定义一个new方法的时候：

xtq = Dog()  
#当调用Dog（）的时候实际是进行了三个步骤：
1.调用new方法创建了一个对象，返回值是这个对象引用
在我们自定义new方法之后如何来判断我们对象创建成功了呢，是通过返回值来判断：return object.__new__(cls)
只要我们创建的new方法里面有上面这行代码就说明我们创建对象创建成功了

这个步骤本质上的做法是：先调用new方法来创建一个对象，然后找了一个变量来接收new的返回值，这个返回值表示创建出来的对象的引用
而init里面的参数就是刚刚创建出来的对象的引用

2.调用__init__(self)方法
当我们创建对象成功了之后我们就会调用init方法，但是我们在调用init方法的时候 需要传入一个self参数，而self参数就是我们刚刚创建的那个对象的引用（self就是一个指针指向的我们刚刚创建的那个对象，也就是return的返回值是和self相同的）

此时的self就是指向的刚刚创建的那个对象

3.返回对象的引用
xtq = Dog()
此时xtq指向的就是刚刚创建出来的那个对象

new方法只负责创建对象，init方法只负责初始化对象。在java中的构造方法实际上就是Python中的创建+初始化

而Dog这个类和cls这个变量都是指向的类的地址
self、new返回的结果、xtq都是指向实例对象的地址


*创建单例对象：
自己一个人，这个模式就是不管创建多少次，仅仅只有一个对象。

例如：
class Dog(object):
    pass

a = Dog()
b = Dog()

此时我们知道a,b指向的是两个不同的实例对象，可以通过id(a)和id(b)来判断是否是同一个实例对象

什么叫单例呢，就是无论创造多少个a，b，c他们都是指向的一个实例对象，判断方法也是使用id()
来判定他们指向的内存地址。

创建一个单例对象：
class Dog(object):
    __instance = None
    def __new__(cls):
        if cls.__instance == None:
            cls.__instance = object.__new__(cls)
            return cls.__instance
        else:
             return cls.__instance

逻辑：
要想让每次对象实例创建的时候都指向的是同一个实例对象，那么思路是把每次创建实例对象的时候都指向第一次创建的那个实例对象，无论创建多少次真正执行的时候都是第一次创建一个对象，但是后面每次调用都是返回第一次创建好的实例对象的引用，这样就能保证单例对象。
而创建对象的步骤实际是在new方法中创建的，因此需要在new方法中进行判断，第一次创建实例对象的时候直接创建一个实例对象，而非第一次创建的时候每次都返回第一个实例对象的引用。
判断的条件：是否是第一次创建，因此需要添加一个类的属性，来检测创建对象的次数
又因为需要返回一个对象的引用，因此还需要定义一个类的属性来保存第一次创建对象的引用。
在创建单例对象这个具体场景中，因为我们只需要判断是否是第一次创建然后保存第一次创建对象的引用，因此为了节省代码和看着简洁只需要定义一个变量就能满足要求（当然定义两个变量也能实现功能，但是闲着啰嗦）
综合以上因素一个完整的单例对象的创建就完成了

单例对象的本质就是在一个类创建实例的对象的时候只创建一次，然后保存第一个实例对象的引用。之后每次使用该类创建实例对象都是返回的第一个实例对象的引用。

*只初始化一次类的属性：
类的私有属相（方法）不能被实例对象直接调用，但是子类继承父类时，子类可以通过父类.属性（方法）来使用父类的私有属性和方法
这里有个代码执行逻辑的错误，看代码：
class Dog(object):
    __instance = None
    def __new__(cls):
        if cls.__instance == None:
            cls.__instance = object.__new__(cls)
            return cls.__instance
        else:
            return cls.__instance

    def __init__(self,name):
        self.name = name

a = Dog('旺财')
print(a.name)   #此时系统会报错，报错的原因是
new方法只有一个参数，我们在调用的时候却传入了两个参数。因为我们在创建的类里面定义了new方法，而在创建实例对象的时候是先调用new方法来创建一个对象，然后才会调用init方法初始化对象，而定义new方法的时候我们只定义了一个cls参数，为了不让new方法报错，我们需要给new方法再传入一个参数（仅仅是为了让程序顺利执行下去，实际我们在new方法中并没有使用该参数）

class Dog(object):
    __instance = None
    def __new__(cls,name):
        if cls.__instance == None:
            cls.__instance = object.__new__(cls)
            return cls.__instance
        else:
            return cls.__instance

    def __init__(self,name):
        self.name = name

a = Dog('哮天犬')
print(id(a))
print(a.name)

b = Dog('旺财')
print(id(b))
print(b.name)

运行程序的时候我们会发现用这个单例对象Dog创建的两个实例对象内存地址指向的是同一个内存地址，但是却输出了‘哮天犬’和‘旺财’两个。
实际上在这个单例对象创建的实例对象中哮天犬和旺财都是对应的一个对象里面的name属性，相当与重写了该对象里面的属性（一个对象里面的同一个属性操作了两次，第二次重写了第一次的属性）

只初始化一些类的属性完整代码：
class Dog(object):
    __instance = None
    __name = None
    def __new__(cls,name):
        if cls.__instance == None:
            cls.__instance = object.__new__(cls)
            return cls.__instance
        else:
            return cls.__instance
    def __init__(self,name):
        if Dog.__name == None: #虽然Dog和cls指向的是同一个内存地址，但是在这不能用cls会报错，要使用Dog类名
            Dog.__name = name
            self.name = Dog.__name
        else:
            self.name = Dog.__name

这里不能使用__instance这个类属性作为init里面的判断方法，因为instance在new方法结束之后就已经改变了内容，不再是None了。因此要定义另外一个类的属性来作为init判断的标准


*异常处理：
什么叫异常：
程序崩了就叫异常
当程序出现异常的时候该怎么处理，如果不对异常进行处理的话那么会导致程序直接崩溃。
在程序处理的时候尽量把异常处理加上
异常处理的几种：
1、try。。。except
try:
    print(num) #try里面写你认为可能出现问题的代码
except  异常的名字:
    print('如果捕获到夜场后做的处理。。。') #except里面写如果出现了异常应该如何处理的代码

示例代码：
try:
    print(num)
    print('----1----')
except: NameError:
    print('如果捕获到异常需要进行的处理')

运行程序后输出：‘如果捕获到异常需要进行的处理’ 程序并没有崩溃，而是直接抛出了except里面的内容
因为并没有打印出‘----1----’，所以当try里面的某行代码出现异常之后，他后面的代码就不会再执行，
如果产生的异常和except那的异常名字一致，那么会执行except内的代码。except中的代码执行完毕之后会按顺序执行except之后的代码。如果try中第一个异常和except中的名字不一致依旧会导致程序崩溃

当然一个try后面可以写多个except，这样只要try中代码爆出的异常和多个except中的某个匹配的话就会执行对应的except中的代码，而不会导致程序直接崩溃，和except的顺序没有什么关系
try:
    open('xxx.txt')
    print(num)
    print('----1----')
except: NameError:
    print('如果捕获到异常需要进行的处理')
except: FileNotFoundError:
    print('文件不存在的异常。。。')

在Python3中如果想在同一个except中捕获多个异常那么可以使用下面的语法：
except(NameError,FileNotFindError):
    print('这里捕获了异常')

这种方法会把所有捕获的异常都用同一种方法处理

try:
    open('xxx.txt')
    print(num)
    print('----1----')
except(NameError,FileNotFindError):
    print('这里捕获了异常')
except: exception:
    print('除了上边except捕获的异常之外其他的异常。。。')

exception是所有异常的总称，就是不管产生什么异常都会统统按照这种方式来处理

此外exception还可以捕获产生异常的系统提示：
except exception as ret: #ret是一个变量名随便命名，用来存储捕获到的异常系统提示
    print('在这里捕获了所有异常')
    print(ret) #这里打印出的内容就是该异常系统提示的内容

try...except..else
except(NameError,FileNotFindError):
    print('这里捕获了异常')
else:
    print('没有异常的时候才会执行的功能')

try...except...else..finally
except(NameError,FileNotFindError):
    print('这里捕获了异常')
else:
    print('没有异常的时候才会执行的功能')
finally:
    print('无论产没产生异常，最后都会执行finally，相当于try结束')

try是可以嵌套的

在程序运行的过程当中按ctrl+c也属于异常，通过键盘打断了正在运行的程序

做异常判断不能一刀切一下把1000行代码都放到try里面去，这样会很麻烦，比较明智的办法是你觉得某个地方会出现问题的时候才加上try，没有问题的时候不要加


异常的传递：只要该异常在try的包涵之中（不一定是直接包涵）就能检测出异常，也就是异常的传递
def test1():
    print(num)
def test3():
    try:
        print('----1----')
        test1()
    except: exception as ret:
        print(ret)

test3()

此时调用test3,虽然在test1中没有try，但是因为test3中有，而且test1在test3的try语句中，因此依旧能检测出异常

*抛出自定义异常：
人为制造了一个异常



*if的各种真假判断：
当判断条件不是判断语句的时候（>等）if的判断条件什么时候是真，什么时候是假
空字符串（""）、0、none、false、空列表或字典（[]、()、{}）条件都为假
其他的情况都为真
if -1: #数字非零都表示真
    pass




*模块的介绍
模块就是在Python中用import语句导入的东西
模块就是一个工具箱，是很多工具的集合
import random  #random就是一个模块，实际上random是random.py是一个py文件，我们称py文件就是一个模块
做某个东西的时候需要一个模块，简单说就是需要一个xxx.py
模块有系统自带的如os模块、也有第三方的需要使用pip install pygame来安装的，还可以自定义模块

*自定义模块
创建一个空的文件夹
里面创建一个py文件sendmsg.py  #里面写一个test1（）方法
然后在写一个模块：main.py
在main.py中写入代码：
import sendmsg  #想使用哪个模块里面的功能就需要先用import引入模块到本程序当中。注意这个模块引入的时候并不是sendmsg.py
sendmsg.test1()


我们用Python编写好代码，当需要执行代码的时候，Python解释器会把代码编译成二进制代码然后交给CPU执行。假如，我们编写了一个10万行代码从程序，当我们运行的时候解释器会把10万行代码转化成二进制，而当程序的某个地方报错（假如第9万行）那么程序就会崩溃，我们修改为bug之后还需要重新进行编译10万行代码，很麻烦费时。因此Python解释器做了一步处理：如果我们运行的代码是用import引入到程序中的，那么当Python解释器遇到import的时候会把import里面的代码编译成二进制代码然后存储到一个文件中（该文件就在main.py同目录下的__pycache__文件下以引入的文件名命名的.pyc文件）
，当我们再次运行程序的时候就不用每次都翻译10万行代码了，而是直接调取已经翻译好的二进制文件执行。提升了程序运行的效率。如果import引入的模块发生了变化，程序执行过程是什么？

把import引入进来的文件翻译后的二进制文件起了个名字叫字节码（字节码的后缀是.pyc是编译之后的代码，不是Python源代码）

Python中另外一种引入其他模块里面代码的方式：from sendmsg inport test1   #test1是sendmsg.py文件中的方法
test1()   

Python中引入某个模块中的多个方法：
from sendmsg import test1,test2
from sendmsg import *  #在实际编程中，尽量少用import *这种方式，因为如果有两个模块，里面有相同名字的两个函数，那么后引入的函数会覆盖掉之前引入的同名函数


import time as tt  #给time这个模块起了一个别名，名字叫tt（好处就是如果以后导入的一个模块名字特别长，在用的时候就会很麻烦，那么直接可以重命名，简写）
tt.sleep(3)

在程序运行的过程中，解释器会优先搜索该程序的缓存中有没有这个模块，如果没有这个模块才会到系统的路径中去搜索

在自定义模块的时候，模块名不要起那种已经存在的模块名（系统模块os，时间模块time等），那样程序可能会报错

为了让大家开发更有效率，在实际开发过程中会给不同的人分配不同的模块，同时也可以解耦，大家各自工作互不影响

在实际开发过程中，编写玩某个模块之后（编写的过程中也应该测，但是最后还要整体测一下模块），需要进行对该模块进行测试，测试的方法就是在模块内执行函数，看是否报错：test1()
这样在模块内执行函数没问题之后，说明在别人调用该模块的时候也不会出问题

在Python程序运行过程中：在你import引入某个模块的时候实际上是把模块里面的代码从头到尾执行一遍，而因为在测试模块的时候在模块内部执行了函数来检验程序是否有问题。当在执行import的时候把模块里面的所有代码执行了一次，会输出一次结果，在本程序调用的时候又执行了一次，因此会输出两次结果
解决问题：在自己测试的时候执行测试函数，在别人调用的时候不执行测试函数
在模块内：print(__name__)当使用Python直接执行该模块的时候打印出来的是一个字符串‘__main__’,当通过别的函数import方式来执行的时候打印的结果是模块的名字（sendmsg）
因此可以通过判断__name__来执行相应的代码，在模块中：
if __name__ == '__main__':
    test1()
也就是在使用Python直接执行模块的时候符合条件，调用test1()测试函数，而通过import来执行的时候不执行test1()测试函数

一个规范的模块写法：
import xxx
class Name(object):
    pass
def xxx():
    pass
...等等等内容

def main():
    pass #在这写测试代码等,表示在使用python直接执行的时候就执行main里面的代码，而别人通过import使用的时候就不会执行main里面的代码

if __name__ == 'main':
    main()

*模块中__all__的作用
在模块内：
__all__ = ['test1'] 这样在别人使用import引用该模块的时候只能引用列表里面的方法，没有在列表里面的是没有暴露出去的
如果没有__all__这个变量，那么都可以被引用，而写了这个变量之后只能列表里面的函数（类、变量）能被引用

*包
import 能直接导入py文件，也能导入文件夹，但是导入py文件之后可以直接文件名.函数名()来使用函数，而导入文件之后并不能文件夹名.文件名.函数名()来使用，会直接保存。那么该如何使用呢？
需要在文件夹下新建一个__init__.py文件，此时该文件夹下应该包含__init__.py以及里面之前已经保存的py文件
包含了__init__.py的文件夹就叫做包
（一个py文件就叫模块，而包含__init__.py的文件夹就叫做包）
在__init__.py中写入：
__all__ = ['sendmsg']  #含义是将来导入文件夹的时候，这个列表里面有哪个py文件，哪个py文件就可以被引用到

此外当使用import 文件夹
的时候，除了会执行__init__.py里面的__all__还会执行init里面定义的其他代码
但是在定义了__all__之后再import sendmsg就会报错，因此在实际开发过程中，init中的代码应该是：
__all__ = ['sendmsg']
from . import sendmsg
这样在使用sendmsg里面的函数的时候就可以直接：
import 文件夹名
文件夹名.sendmsg.test1()


*制作一个模块：
import TestMsg
#含义是导入了当前路径下的TestMsg，如果找到了就会导入，如果没找到就会到系统路径去找（Python默认存放包的路径）
为了保证编写的包，能在任意位置都可以调用（而不是只有在当前路径下才能使用），需要把包放在系统路径下，做法：
在当前路径（TestMsg文件夹）下创建一个setup.py
然后在setup.py内写入:
from distutils.core import setup
setup(...) #按照格式填写参数
创建完了setup.py之后，需要构建模块，在该文件夹所在的命令行中执行：python3 setup.py build
执行完了之后TestMsg文件夹下会多了一个build文件
然后生成发布压缩包：在命令行中执行：python3 setup.py sdist
此时在文件夹下会多一个dist文件夹，里面包含压缩包
现在给大家共享的模块就已经只做好了，也就是dist文件夹下的那个压缩包
包已经只做好了，那么如何给别人使用呢？使用压缩包：把压缩包传到GitHub上去，然后别人下载下来之后解压，解压出来的就是我们封装好的那个包，然后安装到系统里面去：python3 setup.py install
返回的结果里面最后一行：writing ...就是安装成功。


*给程序传参
给函数传参这个比较好理解，给程序传参怎么理解？

一个程序在运行之前，已经准备好给这个程序传一个值了。如：ping 192.168.1.112 ping是一个程序，192.168.1.112就是我们传入的值，当程序运行的时候就会按照我们传入的值去执行程序
又如：python3 setup.py bulid/installl/sdist 在这传入的三个参数不同，执行的结果就不同

给程序传参数即不用等程序运行起来之后在去向用户要参数，在程序运行之前已经给好了参数。程序运行起来之后直接用就行了

*给程序传参操作实例：

程序的功能是一样的，但是根据传入的参数不同输出的结果会不同（如广告牌，功能都是滚动显示广告文字，但是如果只输出一个段广告那么这个广告牌通用性就很差，就可以通过传入不同的参数来调整不同的广告段落）
在程序中的体现就是我在运行程序的时候给他输入一个参数，而不是程序运行起来之后再人工干预传参

如果想在程序中能够接受到在运行程序时传递的参数
首先在程序里面的开头导入一个模块：sys
import sys
然后打印一个变量：sys.argv
print(sys.argv)

执行程序：python3 给程序传参.py
会在命令行中打印出一个结果：['给程序传参.py']
是一个列表，第一个元素是我们执行程序的程序名
然后执行:python3 给程序传参.py a b c d
会在命令行中打印出一个结果：['给程序传参.py','a','b','c','d']
因此sys的模块的argv变量就是用来接收执行程序的时候传递的参数的列表

在程序里面添加一行代码：
name = sys.argv[1]
print('热烈欢迎%s的到来'%name)
执行程序：python3 给程序传参.py  老王
输出结果是：'热烈欢迎老王的到来'
在程序没有修改的前提下，程序的效果发生了改变。这就是给程序传参数的效果


*列表推导式：就是指轻量级循环创建列表
for i in range(10,78):
    print (i)
#输出的结果是10——77
因为range(10) 返回的就是一个列表，然后i从列表里面取值再打印出来
在python2中：range的一个风险是，如果你要了一个很大的内存，会不给你：如range(1,10000000000)会直接报错
如果你用range要了一个很大的内存空间，但是忘了用，那么该内存空间会一直被占用，如果我只用了其中的几个值，那么该内存空间将会大大的浪费掉
在Python3中，没有这个风险，Python3中是你需要哪个值，我就临时生成给你哪个值，占用的内存空间会很小，而不是先生成了，而是你要的时候再给你

简单的生成列表写法：
a = [i for i in range(1,18)]  #注意在中括号中的for循环并没有加冒号，输出的结果是1——17的一个列表[1,2,3,4...,16,17]
这个语法的意思是：每执行一个for循环，i就会被赋值一次并放到列表里面去.for循环只负责循环的次数，for循环前面的那个值是谁，谁就会放到列表中去
b = [11 for i in range(1,18)] #输出的结果是17个11的列表[11,11,...,11]

列表生成式里面还可以添加一个if语句
c = [i for i in range(10) if i%2 ==0]  #注意，for后面并没有冒号，if语句后面也没有冒号
每循环一次i都会有一个值，然后会对这个值进行if判断，看漫步满足条件，如果满足条件就添加到列表中去

d = [ i for i in range(3)  for j in range(2)] #得到的结果是[0,0,1,1,2,2]
e = [ (i,j) for i in range(3)  for j in range(2)] #得到的结果是[(0,0),(0,1),(1,0),(1,1),(2,0),(2,1)] 可以以此类推
就相当于for循环的嵌套


*集合：
c = {11,11,22,22,33,33} 得到的结果是c = {11,22,33}
集合和列表一样也能进行增删改查，查集合的方法可以在命令行中定义一个集合,然后变量名.+按tab键  查里面每个方法如何使用：help(变量名.方法名) 注意方法名后边没有括号
type(c)#集合的类型是set
列表和元组里面的元素可以有相同的，但是集合里面的元素不会有相同的
元组，列表，集合都能存多个数据但是各有各的优缺点
列表：最常用，因为增删改查都能使用
元组：不可改
集合：里面的数据不会有相同的

对列表进行去重：
a = [11,22,11,33]
以前的做法：
b = []
for i in a:
    if i not in b:
        b.append(i)
现在的做法：
f = set(a)  #类比int('100')
得到的结果就是{11,22,33}

b = list(f)
得到的结果就是[11,22,33]





